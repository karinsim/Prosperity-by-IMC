# Prosperity 3 by IMC: Team Island Boy Island

The IMC Prosperity3 challenge is a 15-day trading competition on a virtual market environment. Participants are tasked with building and optimising trading algorithms by backtesting their strategies on provided historical data. The challenge provides a simulated environment where participants can test and evaluate their models against others.

There is also a manual trading component to the challenge, ... (A few words on this)

## The team and their contributions
[**your name**](your link): your contribution (e.g. developed strategy for product X in round X, developed all manual strategies, developed options strategy...)

[**Karin Nakanishi**](https://www.linkedin.com/in/karin-nakanishi/): Developed the utility functions and the structure of `Trader` class during the Tutorial round; developed the trading strategies in every round except for Round 3 (options); oversaw and merged the different strategies developed by team members for submission. 


Honourable mention: Jasper's backtester (link)

## Project Overview
This repository contains the code we used in the IMC Prosperity3 challenge.
In the `main` branch, you will find the final submission files (`roundn_final.py`), as well as the scripts used for calculating the manual trades (`Manualn.py`). 

In the `karin` branch, you will find my Jupyter notebooks, as well as the data and log files used for research.  Each team member's respective branch also contains the implementation of their trading strategies in Python.

<details>
<summary><h3> üõ† Utility Functions (utils.py) </h3></summary>

There are several utility functions to analyse the log files generated by the Prosperity server:

- `get_prices_log`: Extracts price and PnL data from the end-of-round log files.
- `get_tradehistory`: Extracts trade history (both own and market trades) from log files and outputs the data as a pandas dataframe.
- `get_mytrades`: Extracts own trades from the dataframe returned by `get_tradehistory` for a specified product.
- `get_orderbook`: Extracts the orderbook at each timestep, provided that it‚Äôs printed correctly by the Trader class.

Additionally, there are some utility functions for backtesting and research:

- `get_midprice_mm`: Calculates the theoretical midprice corresponding to the prices quoted by the market-making bots placing large orders on both sides. This is inspired by the discovery made by Linear Utilities ([source](https://github.com/ericcccsliu/imc-prosperity-2)).
- `find_signal_..(zscore, momentum, breakout)`: Implements various strategies to identify trading signals based on statistical methods such as z-score, momentum, and breakout patterns.
- `find_spread`: Calculates the spread between the ETF and its synthetic (introduced in Round 2) using the size-weighted mid-price.

With this, we are ready to dive into the competition! üíπ
</details>

<details>
<summary><h3> ü§ë Trader class logic </h3></summary>

- `update_open_pos`: At each timestep, check for new (own) trades, and add the new trades to the dictionaries corresponding to open buy and sell orders. We consider the orders "closed" if there is a profit of at least 1 unit. Used to track the prices at which the algo has previously bought or sold to keep the profits/losses in check. 

- `order_prod`: Implements the trading strategy for each product.

- `run`: First update open positions as described above, then place orders for each product. 
</details>

<details>
<summary><h3> ü¶ë Round 1 </h3></summary>

In Round 1, three products are traded in the exchange: RAINFOREST_RESIN, KELP and SQUID_INK. 

The fairprice of RAINFOREST_RESIN is constant at 10000 according to the market-making bots, but there is some noise around this value due to other bots placing orders below and above this price. Market-taking around this constant fairprice has worked very well, but we could further improve our PnL by market-making - placing bids below and asks above this price. We also cleared our positions by buying and selling at the fairprice when approaching the position limit. This has helped a little, but there was a trade-off between clearing too early (missing out on profitable trades) vs clearing too late (reaching and staying at the position limit for some time).

For KELP, we again calculated the fairprice as the one specified by the market-making bots. Market-taking and -making around this fairprice worked well. We also cleared our positions when it was beyond a certain limit, but made sure to impose a minimum profit of 1 unit against the outstanding orders.

SQUID was highly volatile and had sudden, large spike/drop in prices. Based on the hint, we tried different mean-reversion approaches like Z-score and Ornstein-Uhlenbeck process, but found it difficult to correctly identify the signals.

</details>

<details>
<summary><h3> üß∫ Round 2 </h3></summary>

In Round 2, the idea of ETF and synthetic was introduced. We could trade two PICNIC_BASKETs which corresponded to ETFs, as well as their contents CROISSANTS, JAMS and DJEMBES. As a first attempt, we tried to trade the spread between the basket and their underlying synthetic price, trading each spread independently. However, since the two baskets have similar contents and are highly correlated, we thought it made more sense to trade them together. Some research revealed that with a hedge ratio of ~2, the spread between the two baskets is much more mean-reverting than the individual spread. We thus switched to a pair-trading strategy in Round 5, hedging one basket with the other. This strategy turned out to work much better across different days in backtesting. 

</details>


<details>
<summary><h3> ü™® Round 3 </h3></summary>

Round 3 was all about options. We could trade the products VOLCANIC_ROCK_COUPON_N corresponding to different strike prices N, as well as the underlying asset, VOLCANIC_ROCK. (describe strategy here)


</details>


<details>
<summary><h3> üç™ Round 4 </h3></summary>

Round 4 was somewhat strange. A new product was introduced: MAGNIFICENT_MACARONS. 

</details>
